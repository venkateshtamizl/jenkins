{"version":3,"file":"ConsoleLogStream-D8ITUXhA.js","sources":["../../../../frontend/pipeline-console-view/pipeline-console/main/Ansi.tsx","../../../../frontend/pipeline-console-view/pipeline-console/main/ConsoleLine.tsx","../../../../frontend/pipeline-console-view/pipeline-console/main/ConsoleLogStream.tsx"],"sourcesContent":["export interface Result {\n  isSelectGraphicRendition?: boolean;\n  escapeCode?: string; // input\n  setFG?: number | false; // 0-7 if a foreground color is specified\n  setBG?: number | false; // 0-7 if a background color is specified\n  resetFG?: boolean; // true if contains a reset back to default foreground\n  resetBG?: boolean; // true if contains a reset back to default background\n}\n\n/**\n * Parse an isolated escape code, looking for \"SelectGraphicsRendition\" codes specifically.\n *\n * Result:\n * ```\n * // Supported code\n * {\n *     isSelectGraphicRendition: true,\n *     escapeCode: string, // input\n *     setFG: integer | false, // 0-7 if a foreground color is specified\n *     setBG: integer | false, // 0-7 if a background color is specified\n *     resetFG: bool, // true if contains a reset back to default foreground\n *     resetBG: bool // true if contains a reset back to default background\n * }\n *\n * // Unsupported or malformed code:\n * {\n *     isSelectGraphicRendition: false,\n *     escapeCode: string // input\n * }\n * ```\n */\nexport function parseEscapeCode(escapeCode: string): Result {\n  // eslint-disable-next-line no-control-regex\n  const graphicsPattern = /^\\u001b\\[([;0-9]*)m$/; // We only care about SGR codes\n\n  const result: Result = {\n    isSelectGraphicRendition: false, // True when is a color / font command\n    escapeCode,\n  };\n\n  const match = graphicsPattern.exec(escapeCode);\n\n  if (match) {\n    result.isSelectGraphicRendition = true;\n    result.setFG = false;\n    result.setBG = false;\n    result.resetFG = false;\n    result.resetBG = false;\n\n    // Convert param string to array<int> with length > 1\n    const params = (match[1] || \"\")\n      .split(\";\")\n      .map((str) => parseInt(str || \"0\"));\n\n    // Now go through the ints, decode them into bg/fg info\n    for (const num of params) {\n      if (num >= 30 && num <= 37) {\n        result.setFG = num - 30; // Normal FG set\n      } else if (num >= 40 && num <= 47) {\n        result.setBG = num - 40; // Normal BG set\n      } else {\n        if (num === 38 || num === 0) {\n          result.resetFG = true;\n          result.setFG = false;\n        }\n\n        if (num === 48 || num === 0) {\n          result.resetBG = true;\n          result.setBG = false;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Break up a string into an array of plain strings and escape codes. Returns [input] if no codes present.\n */\nexport function tokenizeANSIString(input?: string): string[] | Result[] {\n  if (typeof input !== \"string\") {\n    return [];\n  }\n\n  const len = input.length;\n\n  if (len === 0) {\n    return [];\n  }\n\n  /*\n    loopCounter         - Where should the next loop start looping for escape codes.\n    escapeCodeIndex     - The index in the string of the next ANSI escape code or -1.\n    parsedPointer       - The parse pointer how far in the string have we parsed.\n                          This will === loopCounter unless there are commented ANSI escape characters.\n    commentStartIndex   - The start index of the next comment block, or -1.\n    commentEndIndex     - The end index of the next comment block, or -1.\n  */\n  let loopCounter = 0;\n  let escapeCodeIndex = 0;\n  let parsedPointer = 0;\n  // comment start\n  let commentStartIndex = 0;\n  // comment end\n  let commentEndIndex = 0;\n  const result: string[] | Result[] = [];\n\n  while (loopCounter < len) {\n    //--------------------------------------------------------------------------\n    //  Find next escape code\n    escapeCodeIndex = input.indexOf(\"\\x1b\", loopCounter);\n\n    if (escapeCodeIndex === -1) {\n      // No more escape codes\n      break;\n    }\n\n    // Check if escape code is commented\n    commentStartIndex = input.indexOf(\"<!--\", loopCounter);\n    commentEndIndex = input.indexOf(\"-->\", commentStartIndex);\n    if (commentEndIndex !== -1) {\n      commentEndIndex += 3;\n    }\n    if (\n      escapeCodeIndex > commentStartIndex &&\n      escapeCodeIndex < commentEndIndex\n    ) {\n      // Skip past the comment\n      loopCounter = commentEndIndex;\n      continue;\n    }\n\n    //--------------------------------------------------------------------------\n    //  Capture any text between the start pointer and the escape code\n\n    if (escapeCodeIndex > loopCounter) {\n      result.push(input.substring(loopCounter, escapeCodeIndex));\n      loopCounter = escapeCodeIndex; // Advance our start pointer to the beginning of the escape code\n    }\n\n    //--------------------------------------------------------------------------\n    //  Find the end of the escape code (a char from 64 - 126 indicating command)\n\n    escapeCodeIndex += 2; // Skip past ESC and '['\n\n    let code = input.charCodeAt(escapeCodeIndex);\n    while (escapeCodeIndex < len && (code < 64 || code > 126)) {\n      escapeCodeIndex++;\n      code = input.charCodeAt(escapeCodeIndex);\n    }\n\n    //--------------------------------------------------------------------------\n    //  Create token for the escape code\n\n    // TODO fix type checking\n    const parsedEscapeCode: any = parseEscapeCode(\n      input.substring(loopCounter, escapeCodeIndex + 1),\n    );\n    result.push(parsedEscapeCode);\n\n    //--------------------------------------------------------------------------\n    //  Keep looking in the rest of the string\n\n    loopCounter = escapeCodeIndex + 1;\n    // Move parsedPointer as we have processes the text to this point.\n    parsedPointer = loopCounter;\n  }\n\n  if (parsedPointer < len) {\n    result.push(input.substr(parsedPointer));\n  }\n\n  return result;\n}\n\n/**\n * Takes an array of string snippets and parsed escape codes produced bv tokenizeANSIString, and creates\n * an array of strings and spans with classNames for attributes.\n */\nexport function makeReactChildren(\n  tokenizedInput: string[] | Result[],\n  key: string,\n) {\n  const result = [];\n  let currentState: Result = {\n    setFG: false,\n    setBG: false,\n  };\n\n  for (let i = 0; i < tokenizedInput.length; i++) {\n    const codeOrString = tokenizedInput[i];\n    if (typeof codeOrString === \"string\") {\n      // Need to output a <span> or plain text if there's no interesting current state\n      if (!currentState.setFG && !currentState.setBG) {\n        result.push(\n          <div\n            dangerouslySetInnerHTML={{ __html: codeOrString }}\n            key={`${key}-${i}`}\n          />,\n        );\n      } else {\n        const classNames = [];\n\n        if (typeof currentState.setFG === \"number\") {\n          classNames.push(`ansi-fg-${currentState.setFG}`);\n        }\n        if (typeof currentState.setBG === \"number\") {\n          classNames.push(`ansi-bg-${currentState.setBG}`);\n        }\n\n        result.push(\n          <span className={classNames.join(\" \")}>{codeOrString}</span>,\n        );\n      }\n    } else if (codeOrString.isSelectGraphicRendition) {\n      // Update the current FG / BG colors for the next text span\n      const nextState = { ...currentState };\n\n      if (codeOrString.resetFG) {\n        nextState.setFG = false;\n      }\n      if (codeOrString.resetBG) {\n        nextState.setBG = false;\n      }\n\n      if (typeof codeOrString.setFG === \"number\") {\n        nextState.setFG = codeOrString.setFG;\n      }\n      if (typeof codeOrString.setBG === \"number\") {\n        nextState.setBG = codeOrString.setBG;\n      }\n\n      currentState = nextState;\n    }\n  }\n\n  return result;\n}\n","import { memo, useEffect, useRef } from \"react\";\n\nimport { makeReactChildren, tokenizeANSIString } from \"./Ansi.tsx\";\n\nexport interface ConsoleLineProps {\n  lineNumber: string;\n  content: string;\n  stepId: string;\n  startByte: number;\n  heightCallback: (height: number) => void;\n}\n\ndeclare global {\n  interface Window {\n    Behaviour: any;\n  }\n}\n\n// Console output line\nexport const ConsoleLine = memo(function ConsoleLine(props: ConsoleLineProps) {\n  const ref = useRef<HTMLDivElement>(null);\n  useEffect(() => {\n    const height = ref.current ? ref.current.getBoundingClientRect().height : 0;\n    props.heightCallback(height);\n\n    // apply any behaviour selectors to the new content, e.g. for input step\n    window.Behaviour.applySubtree(\n      document.getElementById(`${props.stepId}-${props.lineNumber}`),\n    );\n  }, []);\n\n  return (\n    <pre\n      style={{ background: \"none\", border: \"none\" }}\n      className=\"console-output-line\"\n      key={`console-line-pre${props.lineNumber}`}\n    >\n      <div\n        className=\"console-output-line\"\n        key={`${props.lineNumber}-body`}\n        ref={ref}\n      >\n        <a\n          className=\"console-line-number\"\n          id={`log-${props.lineNumber}`}\n          href={`?start-byte=${props.startByte}&selected-node=${props.stepId}#log-${props.lineNumber}`}\n          style={{\n            width: Math.max(9 * String(props.lineNumber).length, 30) + \"px\",\n          }}\n        >\n          {props.lineNumber}\n        </a>\n        <div\n          id={`${props.stepId}-${props.lineNumber}`}\n          className=\"console-text\"\n        >\n          {makeReactChildren(\n            tokenizeANSIString(props.content),\n            `${props.stepId}-${props.lineNumber}`,\n          )}\n        </div>\n      </div>\n    </pre>\n  );\n});\n","import { useCallback, useEffect, useRef, useState } from \"react\";\n\nimport { ConsoleLine } from \"./ConsoleLine.tsx\";\nimport {\n  Result,\n  StepInfo,\n  StepLogBufferInfo,\n} from \"./PipelineConsoleModel.tsx\";\n\nexport default function ConsoleLogStream(props: ConsoleLogStreamProps) {\n  const appendInterval = useRef<NodeJS.Timeout | null>(null);\n  const [stickToBottom, setStickToBottom] = useState(false);\n  const [maxConsoleLineHeight, setMaxConsoleLineHeight] = useState(1);\n\n  useEffect(() => {\n    return () => {\n      if (appendInterval.current) {\n        clearInterval(appendInterval.current);\n      }\n    };\n  }, []);\n\n  useEffect(() => {\n    if (stickToBottom && props.logBuffer.lines.length > 0) {\n      // Scroll to bottom of the log stream\n      if (props.logBuffer.lines) {\n        requestAnimationFrame(() => {\n          const scrollTarget = document.documentElement.scrollHeight;\n          window.scrollTo({ top: scrollTarget });\n        });\n      }\n    }\n  }, [props.logBuffer.lines]);\n\n  useEffect(() => {\n    const handleScroll = () => {\n      const scrollPosition = window.scrollY + window.innerHeight;\n      const pageHeight = document.body.scrollHeight;\n      const isAtBottom = pageHeight - scrollPosition < 300;\n\n      setStickToBottom(isAtBottom);\n    };\n\n    window.addEventListener(\"scroll\", handleScroll);\n    return () => window.removeEventListener(\"scroll\", handleScroll);\n  }, []);\n\n  useEffect(() => {\n    if (stickToBottom && shouldRequestMoreLogs()) {\n      if (!appendInterval.current) {\n        appendInterval.current = setInterval(() => {\n          props.onMoreConsoleClick(props.step.id, props.logBuffer.startByte);\n        }, 1000);\n      }\n    } else if (appendInterval.current) {\n      clearInterval(appendInterval.current);\n      appendInterval.current = null;\n    }\n  }, [stickToBottom, props.step, props.logBuffer]);\n\n  const consoleLineHeightCallback = useCallback(\n    (height: number) => {\n      if (height > maxConsoleLineHeight || maxConsoleLineHeight === 1) {\n        setMaxConsoleLineHeight(height);\n      }\n    },\n    [maxConsoleLineHeight],\n  );\n\n  const shouldRequestMoreLogs = () => {\n    return props.step.state === Result.running || props.logBuffer.startByte < 0;\n  };\n\n  useEffect(() => {\n    const hash = window.location.hash;\n    if (!hash.startsWith(\"#log-\")) {\n      return;\n    }\n    const lineNumber = parseInt(hash.substring(5));\n    if (!isNaN(lineNumber)) {\n      const element = document.getElementById(`log-${lineNumber}`);\n      if (element) {\n        element.scrollIntoView({ behavior: \"smooth\", block: \"center\" });\n        const hash = location.hash;\n        location.hash = \"\";\n        location.hash = hash;\n      }\n    }\n  }, []);\n\n  return (\n    <div role=\"log\">\n      {props.logBuffer.lines.map((content, index) => (\n        <ConsoleLine\n          key={index}\n          lineNumber={String(index)}\n          content={content}\n          stepId={props.step.id}\n          startByte={props.logBuffer.startByte}\n          heightCallback={consoleLineHeightCallback}\n        />\n      ))}\n    </div>\n  );\n}\n\nexport interface ConsoleLogStreamProps {\n  logBuffer: StepLogBufferInfo;\n  onMoreConsoleClick: (nodeId: string, startByte: number) => void;\n  step: StepInfo;\n  maxHeightScale: number;\n}\n"],"names":["parseEscapeCode","escapeCode","graphicsPattern","result","match","params","str","num","tokenizeANSIString","input","len","loopCounter","escapeCodeIndex","parsedPointer","commentStartIndex","commentEndIndex","code","parsedEscapeCode","makeReactChildren","tokenizedInput","key","currentState","i","codeOrString","jsx","classNames","nextState","ConsoleLine","memo","props","ref","useRef","useEffect","height","jsxs","ConsoleLogStream","appendInterval","stickToBottom","setStickToBottom","useState","maxConsoleLineHeight","setMaxConsoleLineHeight","scrollTarget","handleScroll","scrollPosition","isAtBottom","shouldRequestMoreLogs","consoleLineHeightCallback","useCallback","Result","hash","lineNumber","element","content","index"],"mappings":"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"}